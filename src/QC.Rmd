---
title: "Gene and Cell QC"
author: "NadineBestard"
date: "27/02/2021"
output: html_document
editor_options: 
  markdown: 
    wrap: 80
---

# Set-up

```{r set-up, message=FALSE, warning=FALSE}
library(here) # for reproducible paths
library(SingleCellExperiment)
library(scater) # For qc
library(org.Mm.eg.db) # To annotate the genenames
```

```{r load-sce}
sce <- readRDS(here("processed", "sce.RDS"))
```

The object has `r dim(sce)[1]` genes and `r dim(sce)[2]` cells before filtering


# Add cell QC metrics to the sce

First we need to sort the gene names and gene symbols, because the default ensembl
notation is not very handy. And then save the mitochondrial genes as such.

```{r gene-names}
if(!file.exists(here("processed", "sce_preliminary.RDS"))){
# obtain full genenames
genename <- mapIds(org.Mm.eg.db, keys = rownames(sce), keytype = "ENSEMBL", column = c("GENENAME"))
# Use the symbols as rownames
# first make gene names unique 
# TODO: save duplicate gene name list
symb_unique <- uniquifyFeatureNames(rownames(sce), rowData(sce)[, "Symbol"])
# Now they can be used as rownames
rownames(sce) <- symb_unique
# Add full gene names and the uniuqe symbols to the rowdata
rowData(sce)$symb_uniq <- symb_unique
rowData(sce)$gene_name <- genename
# Subset the mitochondrial genes
is_mito <- grepl("^mt-", rownames(sce))
}else{
  sce <- readRDS(here("processed", "sce_preliminary.RDS"))
}
```

Then we can use the scater package to add the quality per cell.
This computes for each cell some usefull metrics such as the number of 
umi counts (library size), the number of detected genes and the percentage 
of mitochondiral genes. 

Then we use the automatic isOutlier function from the same package that determine
which values in a numeric vector are outliers based on the median absolute
deviation (MAD). When using this function with low number a log transformation
is added, that prevents negative thresholds.

```{r addQC}
if(!file.exists(here("processed", "sce_preliminary.RDS"))){
sce <- addPerCellQC(sce, subsets = list(mt=is_mito)) }
# Automated outlier detection
outlier_lib_low <- isOutlier(sce$total, log = TRUE, type = "lower")
outlier_expr_low <-
  isOutlier(sce$detected, log = TRUE, type = "lower")
outlier_lib_high <- isOutlier(sce$total, type = "higher")
outlier_expr_high <-
  isOutlier(sce$detected, type = "higher")
outlier_mt <- isOutlier(sce$subsets_mt_percent, type = "higher")
# total
outlier <-
  outlier_lib_low |
  outlier_expr_low |
  outlier_lib_high | outlier_expr_high | outlier_mt
# See how many cells are detected as outliers
DataFrame(
  lib_size_high = sum(outlier_lib_high),
  expression_high = sum(outlier_expr_high),
  lib_size_low = sum(outlier_lib_low),
  expression_low = sum(outlier_expr_low),
  mt_pct = sum(outlier_mt),
  total = sum(outlier)
)
# And the thresholds
attr(outlier_lib_high, "thresholds")
attr(outlier_expr_high, "thresholds")
attr(outlier_lib_low, "thresholds")
attr(outlier_expr_low, "thresholds")
attr(outlier_mt, "thresholds")
# Add if it is an outlier to the metadata
sce$outlier <- outlier
```

# Plots before QC

Diagnostic plots to visualize the data distribution. The orange cells are marked
as outliers by the automatic detection from scater. These thresholds will probably be manually adjusted to better fit the distribution of our data. 

### Violin plots

```{r}
plotColData(sce, x="Sample", y="sum", colour_by="outlier") + 
  ggtitle("Total count") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
plotColData(sce, x="Sample", y="sum", colour_by="outlier") + 
  scale_y_log10() + ggtitle("Total count log scale") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

```{r}
plotColData(sce, x="Sample", y="detected", colour_by="outlier") + 
  scale_y_log10() + ggtitle("Detected Genes") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

```{r}
plotColData(sce, x="Sample", y="sum", colour_by="chip") + 
  scale_y_log10() + ggtitle("total count by batch") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

```{r}
plotColData(sce, x="Sample", y="subsets_mt_percent", colour_by="outlier") + ggtitle("Mitocchondrial percentatge") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

### Histograms

In the x axis we can see the total number of umi (library size) per cell, the number of detected genes per cell and the mitochondrial percentage per cell; with the number of cells for each measure in the y axis. 


```{r}
hist(
    sce$total,
    breaks = 100
)
```

This object had already been filtrated with the cell-calling algorithm from CellRanger, that is meant to remove empty droplets. Therefore it is expected to see the total sum of umi skewed as in the plot above.

```{r}
hist(
    sce$detected,
    breaks = 100
)
```

A bimodal plot is not something usual for the detected number of genes. This bimodality was already visible in the violin plots. 

```{r}
hist(
    sce$subsets_mt_percent,
    breaks = 100
)
```

There is a very heavy tail of cells with high mitochondrial genes. 

### Scatter plots

```{r}
plotColData(sce, x="sum", y="subsets_mt_percent", colour_by="outlier")
plotColData(sce, x="sum", y="detected", colour_by="outlier")
plotColData(sce, x="sum", y="detected", colour_by="Sample")
```

### PCA

Here we run a PCA using the information in the metadata instead of the gene
expression. It is useful to visualize the QC parametres.

```{r PCA}
if(!file.exists(here("processed", "sce_preliminary.RDS"))){
sce <- runColDataPCA(sce,  variables = c("sum","detected", "subsets_mt_percent"))
}
plotReducedDim(sce, dimred="PCA_coldata", colour_by = "Sample")
sce$chip <- as.character(sce$chip)
plotReducedDim(sce, dimred="PCA_coldata", colour_by = "chip")
```

### Ratio between sum and gene counts

This measures the number of detected genes per cell dividided by its lirary size. This will be very useful to get rid of the cells that have low
gene counts but a relatively high umi count. 

```{r}
if(!file.exists(here("processed", "sce_preliminary.RDS"))){
sce$ratio_detected_sum <- sce$detected/sce$sum
sce$outlier_ratio <- isOutlier(sce$ratio_detected_sum, type = "both")
}

summary(sce$ratio_detected_sum)
plotColData(sce, x="sum", y="detected", colour_by="ratio_detected_sum")
# Plot an histogram with the ratio between umi and gene counts
hist(
    sce$ratio_detected_sum,
    breaks = 100
)
```

The isoutlier function did not work
very well with the sum of umi and the detected genes. This is probably due to the fact that this function expects
roughly a normal distribution. Bellow we use it with the ratio between these two
parametres, that do follow a normal distribution.
```{r}
# Use the is outlier function from scater to see the cutoffs suggestions
plotColData(sce, x="sum", y="detected", colour_by="outlier_ratio")
attr(sce$outlier_ratio, "thresholds")

```

The suggestions here are very reasonable, it is not enough to delete all the
cells we do not trust but we can definitely take this into consideration as a
threshold parameter.

# Decide the thresholds

For the genes detected and sum of genes the upper thresholds automatically
generated are not very convincing.These thresholds allow to filter doublet
cells, but they seem way too harsh on those estimattions. We could start with
50,000 for the number of umi and 7500 for the number of detected genes.

The lower thresholds allow to remove empty droplets and bad quality cells. For
these ones we could use the automatic ones, as they seem more reasonable (even
though they might be a bit too permissive it is fine for a first filer). These
are deleting cells with less than `r attr(outlier_expr_low, "thresholds")["lower"]` detected genes and `r attr(outlier_lib_low, "thresholds")["lower"]` umi counts.

Finally we will also take in consideration the umi counts/detected genes ratio,
that filter out cells with relatively high umi counts but very few detected
genes ( lots of copies from the same genes?). As well as the automatic
mitochondrial threshold, `r attr(outlier_mt, "thresholds")["higher"]`, this is a bit high compared with other datasets but
it is already deleting `r sum(outlier_mt)` cells. Lower down to 10 %, to delete the whole tail would delete `r sum(sce$subsets_mt_percent>10)` cells. 

Here we code the new thersholds
```{r}
if(!file.exists(here("processed", "sce_preliminary.RDS"))){
# New thresholds
discard_lib_high <- sce$sum > 50000
discard_expr_high <- sce$detected > 7500
discard_expr_low <- outlier_expr_low
discard_lib_low <- outlier_lib_low
discard_ratio <- sce$outlier_ratio
discard_mt <- outlier_mt
sce$discard <- discard_lib_high | discard_expr_high | discard_expr_low | discard_lib_low | discard_ratio | discard_mt 

# See how many cells are detected as outliers
discard <- DataFrame(
  lib_size_high = sum(discard_lib_high),
  expression_high = sum(discard_expr_high),
  lib_size_low = sum(discard_lib_low),
  expression_low = sum(discard_expr_low),
  mt_pct = sum(outlier_mt),
  ratio_umi_genes = sum(discard_ratio),
  total = sum(sce$discard)
)
write.csv(discard, here("outs", "reason_for_discard.csv"))
# Save the object at this stage with the label "preliminary analysis" 
# As only annotation addition has been done, without deleting anything yet.
saveRDS(sce, here("processed", "sce_preliminary.RDS"))}else{
  discard <- read.csv(here("outs", "reason_for_discard.csv"))
}
discard

```

## QC with new thresholds


Bellow we are going to plot the same plots as before with the decided thresholds

### Violin plots

```{r umi-discard}
plotColData(sce, x="Sample", y="sum", colour_by="discard") + 
  ggtitle("Total count") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
plotColData(sce, x="Sample", y="sum", colour_by="discard") + 
  scale_y_log10() + ggtitle("Total count log scale") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

```{r detected-discard}
plotColData(sce, x="Sample", y="detected", colour_by="discard") + 
  scale_y_log10() + ggtitle("Detected Genes") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```


```{r mithocondrial-discard}
plotColData(sce, x="Sample", y="subsets_mt_percent", colour_by="discard") + ggtitle("Mitocchondrial percentatge") + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```


### Scatter plots

```{r scatterplots-discard}
plotColData(sce, x="sum", y="subsets_mt_percent", colour_by="discard")
plotColData(sce, x="sum", y="detected", colour_by="discard")
```

# Gene QC

It is typically a good idea to remove genes whose expression level is considered “undetectable”. Here we define a gene as detectable if at least two cells contain a transcript from the gene. It is important to keep in mind that genes must be filtered after cell filtering since some genes may only be detected in poor quality cells.

```{r gene-qc}
genes_beforeqc <- dim(sce)[1]
keep_feature <- rowSums(counts(sce) > 0) > 1
sce <- sce[keep_feature, ]
genes_beforeqc -dim(sce)[1] 
```

This way we deleted `r genes_beforeqc -dim(sce)[1] ` genes and kept `r sum(keep_feature)` genes

We can look at a plot that shows the top 50 (by default) most-expressed features. Each row in the plot below corresponds to a gene; each bar corresponds to the expression of a gene in a single cell; and the circle indicates the median expression of each gene, with which genes are sorted. We expect to see the “usual suspects”, i.e., mitochondrial genes, actin, ribosomal protein, MALAT1. A large number of pseudo-genes or predicted genes may indicate problems with alignment.

```{r}
plotHighestExprs(sce, exprs_values = "counts", colour_cells_by = "age")
```
The young ones are not visible on the low side, but this is just due to the fact that first is plotted one color, and then the other on top, covering the color bellow if there are dots on the same place. 


# Create new filetered object

```{r}
if(!file.exists(here("processed", "sce_QC.RDS"))) {
  sce <- sce[, sce$discard == FALSE]
  saveRDS(sce, here("processed", "sce_QC.RDS"))
}
```

The object has `r dim(sce)[1]` genes and `r dim(sce)[2]` cells after filtering

## Session Info

<details>
  <summary>Click to expand </summary>
```{r}
sessionInfo()
```

